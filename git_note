1..git目录结构
    .git/
        COMMIT_EDITMSG : 最新commit的 -m 参数后的信息
        FETCH_HEAD : 61a9d62c56867e70379e86873487a2e30114e43anot-for-merg   ebranch 'master' of github.com:tyrant0604/dinux 
        HEAD : ref: refs/heads/dev
        ORIG_HEAD : master分支的ID
        config : 用户配置文件，~/.gitconfig是素有用户的配置文件
        description
        hooks
        index
        info
        logs : 记录了分支的变更，可以在错误的reset时，通过refs重新恢复错误的重置
        objects
        refs/
            heads/ : 该目录下的引用称为分支，git rev-parse <branch> : 显示引用对应提交的ID
            remotes/
            tags/

2.HEAD多个父提交的表示
    HEAD^ : HEAD的父提交
    HEAD^^ : HEAD^的父提交
    HEAD~3 : HEAD的第三个父提交

3.git常用命令
    git status
        查看当前工作区的状态
    git add <file>
        将文件加入暂存区

    git commit -m 'message'
        将暂存区的修改提交到分支，并强制附加本次修改的说明

    git diff:
        git diff (default)
            工作区 & 暂存区
        git diff HEAD
            工作区 & 当前分支
        git diff --staged / --cached
            暂存区 & 当前分支

    git reset
        git reset [-q] [<commit>] [--] <paths> : 不会重置引用，也不会改变工作区，而是将制定<commit>下的文件（<paths>）覆盖暂存区的文件
            git reset = git reset HEAD : 将之前git add到暂存区的内容撤出
            git reset HEAD^ : 引用回退一次，暂存区的内容也会指向HEAD^的内容
            git reset -- filename : 只将filename撤出暂存区，是git add filename的反向操作
        git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>] : <commit>是可选项，可以使引用或提交ID；如果省略<commit>，默认使用HEAD
            --hard 会破坏工作区未提交的改动，慎用! 暂存区的目录树会被重写，会被master分支指向的分支指向的目录树所覆盖，但是工作区的不受影响
                该选项会做三件事：
                a.替换引用的指向，引用（HEAD）指向新的提交ID
                b.替换暂存区，替换后，暂存区的内容和引用指向的目录树一致
                c.替换工作区，替换后，工作区的内容和暂存区的内容一致
            --soft 值执行上述a.步骤，只改变引用的指向，不改变工作区和暂存区
                git reset --soft HEAD^ : 如果对之前提交的说明或提交的内容不满意时，将提交撤销可以重新提交
                git commit --amend = 1)git reset --soft HEAD^ ; 2)git commit -e -F .git/COMMIT_EDITMSG
            --mixed 
                git reset --mixed HEAD^ = git reset HEAD^
    
    git reflog show <branch>
        展示分支的所有的操作历史及其ID，可以通过该ID重新恢复reset的过程
        如reset --hard HEAD^^^ 会将commit重置到第三个父提交，同时git log只会显示第三个父提交之前的提交信息，因此git reflog提供了重新恢复的方法

    git rm --cached <file>
        直接从暂存区删除，工作区不受影响

    git checkout 
        本质是修改HEAD本身的指向
        git checkout = git checkout HEAD汇总显示工作区、暂存区和HEAD的差异
        git checkout . / -- <file> : 用暂存区的全部/指定文件替换工作区的文件：危险
        git checkout <branch> -- filename 用制定<branch>的文件替换工作区和暂存区的文件
        git checkout HEAD^ 和 git reset HEAD^ 的区别：
            checkout 仅仅改变HEAD的指向，分支（master/dev...）的指向并未改变，默认情况下HEAD指向分支（master/dev...）；
                git checkout HEAD^ : 此时处于[ditached HEAD-分离头指针]，HEAD并未指向任何分支，在此时对工作区进行的修改都处于一个新建的临时分支下，再执行git checkout <branch>将临时分支的提交合并到分支上；
                如果在临时分支下有多次提交，中间的提交可能会丢失；使用git merge 将之前临时分支中的提交合并到分支上
            reset 改变的是分支的指向，HEAD始终指向分支，reset并没有对HEAD作出任何改变

    git ls-tree -l HEAD
        展示当前分支的目录树
    git ls-files -s
        显示暂存区的目录树，第三个字段是暂存区的编号

    git clean -fd
        清空工作区中没有加入版本库的文件和目录（非跟踪文件和目录）

    git log -n / --oneline / -p / --graph / --pretty=raw,one / HEAD / <branch> /
        提交日志

    git cat-file -option ID
        例: git cat-file commit HEAD
            git cat-file tree HEAD^{tree}
            git cat-file blob HEAD:filename
        展示Git对象ID的属性
        commit对象：
            tree e286fc991426faf5b85cc116c55128544d811d1b
            parent 59c672ef2d8508bb8c86e1e589b6e23b2d1ffda1
            author dx <dingxue0604@pku.edu.cn> 1504947546 +0800
            committer dx <dingxue0604@pku.edu.cn> 1504947546 +0800

            change texts filename
        tree对象保存目录结构
            100644 blob 8b35d0b72c3fa2971d241bb6baa3ce8d8ec5d95e    git_note
            100644 blob f65e3cabbfda63086716edfd1513f538c1cd2043test.py
            100644 blob 8b35d0b72c3fa2971d241bb6baa3ce8d8e  c5d95etext  
        blob对象保存着文件的内容，保存在.git/objects/目录下，以ID的前两位作为目录名，后38位作为文件名

    git stash
        保存当前工作进度？

